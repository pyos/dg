import '/time'
import '/collections'

import 'ansi'
import 'ansi/Key'
import 'ansi/Sequence'
import 'tty'
import 'mix'


ReadlineState = subclass object where
  #: A readline input state.
  #:
  #: Defines stuff such as the current buffer contents, caret position, etc.
  #:
  __init__ = @prompt @buffer @position @cache ~> None

  #: Move the caret to the right.
  #:
  #: right :: int -> ReadlineState
  #:
  right = i ~> ReadlineState @prompt @buffer (@position + i `min` len @buffer) @cache

  #: Move the caret to the left.
  #:
  #: left :: int -> ReadlineState
  #:
  left = i ~> ReadlineState @prompt @buffer (@position - i `max` 0) @cache

  #: Insert a string into the buffer, move the caret if necessary.
  #:
  #: insert :: int str -> ReadlineState
  #:
  insert = i d ~> if
    i < 0     => @insert 0 $ d !! slice (-i) None
    otherwise => ReadlineState @prompt
      (+)
        @buffer !! slice None i + d
        @buffer !! slice i None
      @position + len d * (i <= @position)
      @cache

  #: Erase the characters at position `i`, move the caret accordingly.
  #:
  #: erase :: int (Optional int) -> ReadlineState
  #:
  erase = i length: 1 ~> if
    i < 0     => @erase 0 $ length + i
    otherwise => ReadlineState @prompt
      (+)
        @buffer !! slice None i
        @buffer !! slice (i + length) None
      @position - (length `min` @position - i `max` 0)
      @cache


Readline = subclass object where
  __init__ = *: args **: kwargs ~>
    @tty = tty.Teletype *: args **: kwargs
    # In case subclasses decide to override keybindings, make sure
    # they don't add them to the global mapping.
    @bindings = @bindings.copy!
    None

  #: A mapping of keys to state modificators. Note that a key may be
  #: either a character or an ANSI sequence.
  #:
  #: bindings :: dict str (ReadlineState -> ReadlineState)
  #:
  bindings = dict'
    Key.ENTER,      state -> raise $ StopIteration state.buffer
    Key.RIGHT,      state -> state.right 1
    Key.RIGHT_CTRL, state -> state.right 1
    Key.LEFT,       state -> state.left  1
    Key.LEFT_CTRL,  state -> state.left  1
    Key.END,        state -> state.right $ len state.buffer
    Key.END_ALT,    state -> state.right $ len state.buffer
    Key.END_CTRL,   state -> state.right $ len state.buffer
    Key.HOME,       state -> state.left    state.position
    Key.HOME_ALT,   state -> state.left    state.position
    Key.HOME_CTRL,  state -> state.left    state.position
    Key.DEL_ANSI,   state -> state.erase   state.position
    Key.DEL_ASCII,  state -> state.erase $ state.position - 1
    Key.DEL_CTRL,   state -> state.erase $ state.position - 1
    Key.EOF,        state -> if
      state.buffer => state.erase state.position
      otherwise    => raise EOFError

  #: Whether to enable ^C and ^Z. Disallows the use of `Key.SIGINT` and `Key.SUSPEND`.
  #:
  #: enable_jobs :: bool
  #:
  enable_jobs = True

  #: Whether to enable XON/XOFF, whatever that means. Disables `Key.XON` and `Key.XOFF`.
  #:
  #: enable_flowctl :: bool
  #:
  enable_flowctl = False

  #: Default line preprocessor. Does nothing.
  #:
  #: This method is called whenever an updated display is required.
  #: Its only argument is the buffer, and the return value should
  #: be an ANSI-escaped string to display. This could be used,
  #: for example, to implement syntax highlighting.
  #:
  #: NOTE: this method must NOT change the apparent length of a string.
  #:   Otherwise, the caret will appear in the wrong position.
  #:
  #: preprocess :: str -> str
  #:
  preprocess = ln ~> ln

  #: Read a line from a TTY while displaying a preview on another TTY.
  #:
  #: If the prompt is a function, it will be called with the current
  #: `ReadlineState` whenever the display is updated.
  #:
  #: input :: (Either str (ReadlineState -> str)) (Optional float) -> str
  #:
  input = prompt timeout: 0 buffer: '' position: 0 ~>
    with @tty.nonblocking => with @tty.raw @enable_jobs @enable_flowctl => except
      err =>
        start = time.time!
        state = @update $ ReadlineState prompt buffer position {}
        while True =>
          passed = min timeout $ time.time! - start
          passed >= timeout > 0 => raise $ BlockingIOError state

          for c in @tty.buffer (timeout - passed) => state = @update $ if
            @bindings.get  c => (@bindings !! c) state
            @tty.printable c => state.insert state.position c
            otherwise        =>
              @tty.write Key.ALARM
              state
      err :: StopIteration => err.value
      finally => @finalize state

  #: Write a preview of a line buffer onto a TTY.
  #:
  #: update :: ReadlineState -> ReadlineState
  #:
  update = state ~>
    prefix = if
      state.prompt :: collections.Callable => state.prompt state
      otherwise => state.prompt
    prelen = @tty.ansi_len prefix

    # We're going to assume the VT handles windows resizing correctly
    # (i.e. rewraps long lines.)
    wh, ww = @tty.size
    h, w = prelen + len state.buffer `divmod` ww
    y, x = prelen + state.position   `divmod` ww
    # 1. Go to where the last prompt started, overwrite it with new data.
    #    If its start is already off the screen, we'll just go where we can.
    @erase state
    @tty.write $ prefix + @preprocess state.buffer
    # 2. Go back to the beginning. Note: if the string fits
    #    exactly on one line and the cursor is still there,
    #    VTs won't create an empty line.
    if w == 0 and (y, x) != (h, w) => @tty.relmove (1 - h) (-ww)
       otherwise => @tty.relmove (-h) (-w)
    # 3. Move to where the caret should be. Note that (0, 0) may be off-screen,
    #    and terminals will truncate offsets.
    @tty.relmove (y - (h - wh `max` 0)) x
    @tty.flush
    # The next `update` will use that info.
    state.cache !! 'lastpos'  = prelen + state.position
    state.cache !! 'termsize' = wh, ww
    state

  #: Move the cursor to the start of the prompt and erase it.
  #:
  #: erase :: ReadlineState -> ReadlineState
  #:
  erase = state ~>
    _h, _w = state.cache.get 'termsize' (0, 1)
    _y, _x = state.cache.pop 'lastpos' 0 `divmod` _w
    @tty.relmove (-_y) (-_x)
    @tty.erase
    state

  #: Move the cursor to the end of the text.
  #: This allows key handlers to print other stuff between prompts.
  #: Don't forget to call `update` later.
  #:
  #: finalize :: ReadlineState -> ReadlineState
  #:
  finalize = state ~>
    @update $ state.right $ len state.buffer - state.position
    @tty.write '\n\r'
    state.cache.pop 'lastpos' 0
    state
